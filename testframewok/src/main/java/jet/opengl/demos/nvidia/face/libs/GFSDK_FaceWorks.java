package jet.opengl.demos.nvidia.face.libs;

import java.nio.ByteBuffer;
import java.util.Arrays;

import jet.opengl.postprocessing.util.Numeric;

/**
 * NVIDIA FaceWorks<br>
 * ----------------<br>
 * v1.00<p></p>
 *
 * FaceWorks is a middleware library for high-quality skin rendering, inspired by the
 * techniques used in NVIDIA's "Digital Ira" demo.<br></br>
 * (http://www.nvidia.com/coolstuff/demos#!/lifelike-human-face-rendering)<p></p>
 *
 * Digital Ira is a tech demo, created by NVIDIA in collaboration with Dr. Paul Debevec's team at USC,
 * in which a high-resolution head scan and performance capture are rendered as realistically as
 * possible in real-time, using every rendering technique the demo team could think of.  FaceWorks, in
 * contrast, aims to be a reusable, production-ready library, with the goal of enabling game developers
 * to match the rendering quality of Digital Ira.<p></p>
 *
 * FaceWorks currently provides two main features:<ul>
 *
 * <li> A high-quality, efficient subsurface scattering solution, which supports both direct and ambient
 *   light.
 * <li> An implementation of deep scattering (translucency) for direct light, based on estimating
 *   thickness from a shadow map.</ul>
 * 
 * Currently, Direct3D 11 is the only API supported by FaceWorks.<p></p>
 *
 * For detailed documentation please see doc/html/ in the archive.
 * A sample application can be found in the samples/ subdirectory.<p></p>
 * Created by mazhen'gui on 2017/9/4.
 */

public final class GFSDK_FaceWorks {
    /** Header version number - used to check that the header matches the DLL. */
    /*public*/ static final int GFSDK_FaceWorks_HeaderVersion = 100;

    /**
     * Retrieves the version number of the .dll actually being used
     * @return the binary version as an integer (version is multiplied by 100)
     */
    public static int GFSDK_FaceWorks_GetBinaryVersion(){
        return GFSDK_FaceWorks_HeaderVersion;
    }

    /**
     * Retrive baked-in build info string (branch, date/time, versions, etc.)
     * @return a string containing the build information
     */
    public static String GFSDK_FaceWorks_GetBuildInfo(){
        return "GFSDK_FaceWorks_HeaderVersion: " +GFSDK_FaceWorks_HeaderVersion + "\n" + "Built on: Java platform \n";
    }

    /** Internal initialization function. Should not be called directly. */
    static GFSDK_FaceWorks_Result GFSDK_FaceWorks_Init_Internal(int headerVersion) {
        if (headerVersion != GFSDK_FaceWorks_GetBinaryVersion())
            return GFSDK_FaceWorks_Result.VersionMismatch;

        return GFSDK_FaceWorks_Result.OK;
    }

    /**
     * Initialize FaceWorks, and checks that the header version matches the DLL version.
     * @return GFSDK_FaceWorks.OK if binary and header version does not match and the library has been initialized properly, or GFSDK_FaceWorks_Mismatch if versions does not match
     */
    public static GFSDK_FaceWorks_Result GFSDK_FaceWorks_Init() {
        return GFSDK_FaceWorks_Init_Internal(GFSDK_FaceWorks_HeaderVersion);
    }

    // =================================================================================
//	Building mesh data for SSS
// =================================================================================

    /**
     * Calculate size needed to store curvatures generated by GFSDK_FaceWorks_CalculateMeshCurvature.<br>
     * Assuming they're not interleaved with any other vertex components
     * @param vertexCount number of vertices
     * @return the size to store curvatures generated by GFSDK_FaceWorks_CalculateMeshCurvature, or zero if vertexCount is negative
     */
    public static int GFSDK_FaceWorks_CalculateCurvatureSizeBytes(int vertexCount){
        return /*sizeof(float)*/4 * Math.max(0, vertexCount);
    }

    private static void ErrPrintf(GFSDK_FaceWorks_ErrorBlob out, String reg, Object...args){
        if(out != null){
            out.m_msg = String.format("Error: " + reg, args);
        }
    }

    private static void WarnPrintf(GFSDK_FaceWorks_ErrorBlob out, String reg, Object...args){
        if(out != null){
            out.m_msg = String.format("Warning: " + reg, args);
        }
    }
    /**
     * Generate per-vertex curvature for SSS.<br>
     * The positions and normals of the mesh are assumed to be in float3 format and the
     * curvature is written out as a single float per vertex.
     * Indices are assumed to be 32-bit ints.
     * One or more smoothing passes can also be done on the calculated curvatures.
     * @param vertexCount [in]the vertex count
     * @param pPositions [in]pointer to the positions (per-vertex)
     * @param positionStrideBytes [in]distance, in bytes, between two positions in the pPosition buffer
     * @param pNormals [in]pointer to the normals (per-vertex)
     * @param normalStrideBytes [in]distance, in bytes, between two normals in the pNormal buffer
     * @param indexCount [in]the index count
     * @param pIndices [in]pointer to the indices buffer
     * @param smoothingPassCount [in]number of smoothing passes applied to the curvatures
     * @param pCurvaturesOut [out]pointer to the curvatures buffer (written by this function)
     * @param curvatureStrideBytes [in]distance, in bytes, between two curvatures in the pCurvaturesOut
     * @param pErrorBlobOut [in]buffer the error blob, where errors are stored.Error messages will be stored in the error blob, if one is given;
     *								if error messages are generated, use GFSDK_FaceWorks_FreeErrorBlob()
     *								to free the storage.
     *								The given allocator will be used to allocate temporary storage for
     *								working data, if provided; if not, the standard CRT allocator will
     *								be used.
     * @return GFSDK_FaceWorks.OK if parameters are correct.GFSDK_FaceWorks.InvalidArgument if pConfig contains invalid values
     */
    public static GFSDK_FaceWorks_Result GFSDK_FaceWorks_CalculateMeshCurvature(
            int vertexCount,
            float[] pPositions,
            int positionStrideBytes,
            int positionOffsetBytes,
            float[] pNormals,
            int normalStrideBytes,
            int normalOffsetBytes,
            int indexCount,
            int[] pIndices,
            int smoothingPassCount,
            float[] pCurvaturesOut,
            int curvatureStrideBytes,
            GFSDK_FaceWorks_ErrorBlob  pErrorBlobOut){
        // Validate parameters
        if (vertexCount < 1)
        {
            ErrPrintf(pErrorBlobOut, "vertexCount is %d; should be at least 1\n", vertexCount);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pPositions == null)
        {
            ErrPrintf(pErrorBlobOut, "pPositions is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (positionStrideBytes < 3 * /*int(sizeof(float))*/4)
        {
            ErrPrintf(pErrorBlobOut, "positionStrideBytes is %d; should be at least %d\n",
                    positionStrideBytes, 3 * /*sizeof(float)*/4);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pNormals == null)
        {
            ErrPrintf(pErrorBlobOut, "pNormals is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (normalStrideBytes < 3 * /*int(sizeof(float))*/4)
        {
            ErrPrintf(pErrorBlobOut, "normalStrideBytes is %d; should be at least %d\n",
                    normalStrideBytes, 3 * /*sizeof(float)*/4);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (indexCount < 3)
        {
            ErrPrintf(pErrorBlobOut, "indexCount is %d; should be at least 3\n", indexCount);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pIndices == null)
        {
            ErrPrintf(pErrorBlobOut, "pIndices is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (smoothingPassCount < 0)
        {
            ErrPrintf(pErrorBlobOut, "smoothingPassCount is %d; should be at least 0\n", smoothingPassCount);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pCurvaturesOut == null)
        {
            ErrPrintf(pErrorBlobOut, "pCurvaturesOut is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (curvatureStrideBytes < /*int(sizeof(float))*/4)
        {
            ErrPrintf(pErrorBlobOut, "curvatureStrideBytes is %d; should be at least %d\n",
                    curvatureStrideBytes, /*sizeof(float)*/4);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        // Calculate per-vertex curvature.  We do this by estimating the curvature along each
        // edge using the change in normals between its vertices; then we set each vertex's
        // curvature to the midpoint of the minimum and maximum over all the edges touching it.

        int triCount = indexCount / 3;
        positionStrideBytes /= 4;
        positionOffsetBytes /= 4;
        normalStrideBytes   /= 4;
        normalOffsetBytes   /= 4;
        curvatureStrideBytes/= 4;

        // Catch out-of-memory exceptions
        try
        {
//            FaceWorks_Allocator<float> allocFloat(pAllocator);
//            std::vector<float, FaceWorks_Allocator<float>> curvatureMin(vertexCount, FLT_MAX, allocFloat);
//            std::vector<float, FaceWorks_Allocator<float>> curvatureMax(vertexCount, 0.0f, allocFloat);
            float[] curvatureMin = new float[vertexCount];
            float[] curvatureMax = new float[vertexCount];
            Arrays.fill(curvatureMin, Float.MAX_VALUE);

            // !!!UNDONE: SIMD-ize or GPU-ize all this math

            for (int iTri = 0; iTri < triCount; ++iTri)
            {
//                int indices[] =
//                        {
//                                pIndices[3*iTri],
//                                pIndices[3*iTri + 1],
//                                pIndices[3*iTri + 2],
//                        };
                final int indices0 = pIndices[3*iTri];
                final int indices1 = pIndices[3*iTri+1];
                final int indices2 = pIndices[3*iTri+2];

//                float * pos[] =
//                {
//                    reinterpret_cast<float *>((char *)pPositions + indices[0] * positionStrideBytes),
//                    reinterpret_cast<float *>((char *)pPositions + indices[1] * positionStrideBytes),
//                    reinterpret_cast<float *>((char *)pPositions + indices[2] * positionStrideBytes),
//                };
                final int pos0 = indices0 * positionStrideBytes + positionOffsetBytes;
                final int pos1 = indices1 * positionStrideBytes + positionOffsetBytes;
                final int pos2 = indices2 * positionStrideBytes + positionOffsetBytes;

//                float * normal[] =
//                {
//                    reinterpret_cast<float *>((char *)pNormals + indices[0] * normalStrideBytes),
//                    reinterpret_cast<float *>((char *)pNormals + indices[1] * normalStrideBytes),
//                    reinterpret_cast<float *>((char *)pNormals + indices[2] * normalStrideBytes),
//                };
                final int normal0 = indices0 * normalStrideBytes + normalOffsetBytes;
                final int normal1 = indices1 * normalStrideBytes + normalOffsetBytes;
                final int normal2 = indices2 * normalStrideBytes + normalOffsetBytes;

                // Calculate each edge's curvature - most edges will be calculated twice this
                // way, but it's hard to fix that while still making sure to handle boundary edges.

//                float dPx = pos[1][0] - pos[0][0];
//                float dPy = pos[1][1] - pos[0][1];
//                float dPz = pos[1][2] - pos[0][2];
                float dPx = pPositions[pos1] - pPositions[pos0];
                float dPy = pPositions[pos1+1] - pPositions[pos0+1];
                float dPz = pPositions[pos1+2] - pPositions[pos0+2];

//                float dNx = normal[1][0] - normal[0][0];
//                float dNy = normal[1][1] - normal[0][1];
//                float dNz = normal[1][2] - normal[0][2];
                float dNx =pNormals[normal1] - pNormals[normal0];
                float dNy =pNormals[normal1+1] - pNormals[normal0+1];
                float dNz =pNormals[normal1+2] - pNormals[normal0+2];

                float curvature = (float) Math.sqrt((dNx*dNx + dNy*dNy + dNz*dNz) / (dPx*dPx + dPy*dPy + dPz*dPz));
                curvatureMin[indices0] = Math.min(curvatureMin[indices0], curvature);
                curvatureMin[indices1] = Math.min(curvatureMin[indices1], curvature);
                curvatureMax[indices0] = Math.max(curvatureMax[indices0], curvature);
                curvatureMax[indices1] = Math.max(curvatureMax[indices1], curvature);

//                dPx = pos[2][0] - pos[1][0];
//                dPy = pos[2][1] - pos[1][1];
//                dPz = pos[2][2] - pos[1][2];
                dPx = pPositions[pos2] - pPositions[pos1];
                dPy = pPositions[pos2+1] - pPositions[pos1+1];
                dPz = pPositions[pos2+2] - pPositions[pos1+2];

//                dNx = normal[2][0] - normal[1][0];
//                dNy = normal[2][1] - normal[1][1];
//                dNz = normal[2][2] - normal[1][2];
                dNx = pNormals[normal2] - pNormals[normal1];
                dNy = pNormals[normal2+1] - pNormals[normal1+1];
                dNz = pNormals[normal2+2] - pNormals[normal1+2];
                curvature = (float) Math.sqrt((dNx*dNx + dNy*dNy + dNz*dNz) / (dPx*dPx + dPy*dPy + dPz*dPz));
                curvatureMin[indices1] = Math.min(curvatureMin[indices1], curvature);
                curvatureMin[indices2] = Math.min(curvatureMin[indices2], curvature);
                curvatureMax[indices1] = Math.max(curvatureMax[indices1], curvature);
                curvatureMax[indices2] = Math.max(curvatureMax[indices2], curvature);

//                dPx = pos[0][0] - pos[2][0];
//                dPy = pos[0][1] - pos[2][1];
//                dPz = pos[0][2] - pos[2][2];
                dPx = pPositions[pos0+0] - pPositions[pos2+0];
                dPy = pPositions[pos0+1] - pPositions[pos2+1];
                dPz = pPositions[pos0+2] - pPositions[pos2+2];
//                dNx = normal[0][0] - normal[2][0];
//                dNy = normal[0][1] - normal[2][1];
//                dNz = normal[0][2] - normal[2][2];
                dNx = pNormals[normal0+0] - pNormals[normal2+0];
                dNy = pNormals[normal0+1] - pNormals[normal2+1];
                dNz = pNormals[normal0+2] - pNormals[normal2+2];
                curvature = (float) Math.sqrt((dNx*dNx + dNy*dNy + dNz*dNz) / (dPx*dPx + dPy*dPy + dPz*dPz));
                curvatureMin[indices2] = Math.min(curvatureMin[indices2], curvature);
                curvatureMin[indices0] = Math.min(curvatureMin[indices0], curvature);
                curvatureMax[indices2] = Math.max(curvatureMax[indices2], curvature);
                curvatureMax[indices0] = Math.max(curvatureMax[indices0], curvature);
            }

            for (int i = 0; i < vertexCount; ++i)
            {
//                float * pCurvature = reinterpret_cast<float *>((char *)pCurvaturesOut + i * curvatureStrideBytes);
//                *pCurvature = 0.5f * (curvatureMin[i] + curvatureMax[i]);
                int index = i * curvatureStrideBytes;
                pCurvaturesOut[index] = 0.5f * (curvatureMin[i] + curvatureMax[i]);
            }

            curvatureMax = null;
            curvatureMin = null;
        }
        catch (OutOfMemoryError e)
        {
            return GFSDK_FaceWorks_Result.OutOfMemory;
        }

        if (smoothingPassCount > 0)
        {
            // Catch out-of-memory exceptions
            try
            {
//                FaceWorks_Allocator<float> allocFloat(pAllocator);
//                std::vector<float, FaceWorks_Allocator<float>> curvatureSum(allocFloat);
//                curvatureSum.resize(vertexCount);
                final float[] curvatureSum = new float[vertexCount];

//                FaceWorks_Allocator<int> allocInt(pAllocator);
//                std::vector<int, FaceWorks_Allocator<int>> curvatureCount(allocInt);
//                curvatureCount.resize(vertexCount);
                final int[] curvatureCount = new int[vertexCount];

                // Run a couple of smoothing passes, replacing each vert's curvature
                // by the average of its neighbors'

                for (int iPass = 0; iPass < smoothingPassCount; ++iPass)
                {
                    for (int i = 0; i < vertexCount; ++i)
                    {
                        curvatureSum[i] = 0.0f;
                        curvatureCount[i] = 0;
                    }

                    for (int iTri = 0; iTri < triCount; ++iTri)
                    {
//                        int indices[] =
//                                {
//                                        pIndices[3*iTri],
//                                        pIndices[3*iTri + 1],
//                                        pIndices[3*iTri + 2],
//                                };
                        final int indices0 = pIndices[3*iTri];
                        final int indices1 = pIndices[3*iTri+1];
                        final int indices2 = pIndices[3*iTri+2];

//                        float curvature0 = *reinterpret_cast<float *>((char *)pCurvaturesOut + indices[0] * curvatureStrideBytes);
//                        float curvature1 = *reinterpret_cast<float *>((char *)pCurvaturesOut + indices[1] * curvatureStrideBytes);
//                        float curvature2 = *reinterpret_cast<float *>((char *)pCurvaturesOut + indices[2] * curvatureStrideBytes);
                        float curvature0 = pCurvaturesOut[indices0 * curvatureStrideBytes];
                        float curvature1 = pCurvaturesOut[indices1 * curvatureStrideBytes];
                        float curvature2 = pCurvaturesOut[indices2 * curvatureStrideBytes];

                        curvatureSum[indices0] += curvature1 + curvature2;
                        curvatureCount[indices0] += 2;

                        curvatureSum[indices1] += curvature2 + curvature0;
                        curvatureCount[indices1] += 2;

                        curvatureSum[indices2] += curvature0 + curvature1;
                        curvatureCount[indices2] += 2;
                    }

                    for (int i = 0; i < vertexCount; ++i)
                    {
//                        float * pCurvature = reinterpret_cast<float *>((char *)pCurvaturesOut + i * curvatureStrideBytes);
//                        *pCurvature = curvatureSum[i] / float(max(1, curvatureCount[i]));
                        int index = i * curvatureStrideBytes;
                        pCurvaturesOut[index] = curvatureSum[i] / Math.max(1, curvatureCount[i]);
                    }
                }
            }
            catch (OutOfMemoryError e)
            {
                return GFSDK_FaceWorks_Result.OutOfMemory;
            }
        }

        return GFSDK_FaceWorks_Result.OK;
    }

    /**
     * Calculate average UV scale.<p></p>
     * The positions and UVs of the mesh are assumed to be in float3 and float2 format, respectively.Indices are assumed to be 32-bit ints.
     * @param vertexCount [in] the vertex count
     * @param pPositions [in] pointer to the positions (per-vertex)
     * @param positionStrideBytes [in] distance, in bytes, between two positions in the pPosition buffer
     * @param pUVs [in] pointer to the UV coordinates (per-vertex)
     * @param uvStrideBytes [in] distance, in bytes, between two UV coordinates in the pUVs buffer
     * @param indexCount [in] the index count
     * @param pIndices [in] pointer to the indices buffer
     * @param pAverageUVScaleOut [out] pointer to a float where the average UV scale will be stored
     * @param pErrorBlobOut [in] buffer the error blob, where errors are stored.
     *                      Error messages will be stored in the error blob, if one is given;
     *								if error messages are generated, use GFSDK_FaceWorks_FreeErrorBlob()
     *								to free the storage.
     *								The given allocator will be used to allocate temporary storage for
     *								working data, if provided; if not, the standard CRT allocator will
     *								be used.
     * @return GFSDK_FaceWorks.OK if parameters are correct, GFSDK_FaceWorks.InvalidArgument if pConfig contains invalid values
     */
    public static GFSDK_FaceWorks_Result  GFSDK_FaceWorks_CalculateMeshUVScale(
            int vertexCount,
            float[] pPositions,
            int positionStrideBytes,
            int positionOffsetBytes,
            float[] pUVs,
            int uvStrideBytes,
            int uvOffsetBytes,
            int indexCount,
            int[] pIndices,
            float[] pAverageUVScaleOut,
            GFSDK_FaceWorks_ErrorBlob pErrorBlobOut){
        // Validate parameters
        if (vertexCount < 1)
        {
            ErrPrintf(pErrorBlobOut, "vertexCount is %d; should be at least 1\n", vertexCount);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pPositions == null)
        {
            ErrPrintf(pErrorBlobOut, "pPositions is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (positionStrideBytes < 3 * /*int(sizeof(float))*/4)
        {
            ErrPrintf(pErrorBlobOut, "positionStrideBytes is %d; should be at least %d\n",
                    positionStrideBytes, 3 * /*sizeof(float)*/4);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pUVs == null)
        {
            ErrPrintf(pErrorBlobOut, "pUVs is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (uvStrideBytes < 2 * /*int(sizeof(float))*/4)
        {
            ErrPrintf(pErrorBlobOut, "uvStrideBytes is %d; should be at least %d\n",
                    uvStrideBytes, 2 * /*sizeof(float)*/4);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (indexCount < 3)
        {
            ErrPrintf(pErrorBlobOut, "indexCount is %d; should be at least 3\n", indexCount);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (indexCount % 3 != 0)
        {
            ErrPrintf(pErrorBlobOut, "indexCount is %d; should be a multiple of 3\n", indexCount);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pIndices == null)
        {
            ErrPrintf(pErrorBlobOut, "pIndices is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pAverageUVScaleOut == null)
        {
            ErrPrintf(pErrorBlobOut, "pAverageUVScaleOut is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        // Calculate average UV scale, as a geometric mean of scale for each triangle

        float logUvScaleSum = 0.0f;
        int logUvScaleCount = 0;

        positionStrideBytes /= 4;
        positionOffsetBytes /= 4;
        uvStrideBytes /= 4;
        uvOffsetBytes /= 4;

        // !!!UNDONE: SIMD-ize or GPU-ize all this math

        for (int iIndex = 0; iIndex < indexCount; iIndex += 3)
        {
//            int indices[] =
//                    {
//                            pIndices[iIndex],
//                            pIndices[iIndex + 1],
//                            pIndices[iIndex + 2],
//                    };
            final int indices0 = pIndices[iIndex];
            final int indices1 = pIndices[iIndex+1];
            final int indices2 = pIndices[iIndex+2];

//            float * pos[] =
//            {
//                reinterpret_cast<float *>((char *)pPositions + indices[0] * positionStrideBytes),
//                reinterpret_cast<float *>((char *)pPositions + indices[1] * positionStrideBytes),
//                reinterpret_cast<float *>((char *)pPositions + indices[2] * positionStrideBytes),
//            };
            final int pos0 = indices0 * positionStrideBytes+positionOffsetBytes;
            final int pos1 = indices1 * positionStrideBytes+positionOffsetBytes;
            final int pos2 = indices2 * positionStrideBytes+positionOffsetBytes;

//            float * uv[] =
//            {
//                reinterpret_cast<float *>((char *)pUVs + indices[0] * uvStrideBytes),
//                reinterpret_cast<float *>((char *)pUVs + indices[1] * uvStrideBytes),
//                reinterpret_cast<float *>((char *)pUVs + indices[2] * uvStrideBytes),
//            };
            final int uv0 = indices0 * uvStrideBytes+uvOffsetBytes;
            final int uv1 = indices1 * uvStrideBytes+uvOffsetBytes;
            final int uv2 = indices2 * uvStrideBytes+uvOffsetBytes;

            // Find longest edge length in local space
//            float dP0x = pos[1][0] - pos[0][0];
//            float dP0y = pos[1][1] - pos[0][1];
//            float dP0z = pos[1][2] - pos[0][2];
//            float dP1x = pos[2][0] - pos[1][0];
//            float dP1y = pos[2][1] - pos[1][1];
//            float dP1z = pos[2][2] - pos[1][2];
//            float dP2x = pos[0][0] - pos[2][0];
//            float dP2y = pos[0][1] - pos[2][1];
//            float dP2z = pos[0][2] - pos[2][2];
            float dP0x = pPositions[pos1+0] - pPositions[pos0+0];
            float dP0y = pPositions[pos1+1] - pPositions[pos0+1];
            float dP0z = pPositions[pos1+2] - pPositions[pos0+2];
            float dP1x = pPositions[pos2+0] - pPositions[pos1+0];
            float dP1y = pPositions[pos2+1] - pPositions[pos1+1];
            float dP1z = pPositions[pos2+2] - pPositions[pos1+2];
            float dP2x = pPositions[pos0+0] - pPositions[pos2+0];
            float dP2y = pPositions[pos0+1] - pPositions[pos2+1];
            float dP2z = pPositions[pos0+2] - pPositions[pos2+2];

            float diameter = (float) Math.sqrt(Math.max(dP0x*dP0x + dP0y*dP0y + dP0z*dP0z,
                    Math.max(dP1x*dP1x + dP1y*dP1y + dP1z*dP1z,
                            dP2x*dP2x + dP2y*dP2y + dP2z*dP2z)));

            // Find longest edge length in UV space
//            float dUV0x = uv[1][0] - uv[0][0];
//            float dUV0y = uv[1][1] - uv[0][1];
//            float dUV1x = uv[2][0] - uv[1][0];
//            float dUV1y = uv[2][1] - uv[1][1];
//            float dUV2x = uv[0][0] - uv[2][0];
//            float dUV2y = uv[0][1] - uv[2][1];
            float dUV0x = pUVs[uv1+0] - pUVs[uv0+0];
            float dUV0y = pUVs[uv1+1] - pUVs[uv0+1];
            float dUV1x = pUVs[uv2+0] - pUVs[uv1+0];
            float dUV1y = pUVs[uv2+1] - pUVs[uv1+1];
            float dUV2x = pUVs[uv0+0] - pUVs[uv2+0];
            float dUV2y = pUVs[uv0+1] - pUVs[uv2+1];

            float uvDiameter = (float) Math.sqrt(Math.max(dUV0x*dUV0x + dUV0y*dUV0y,
                    Math.max(dUV1x*dUV1x + dUV1y*dUV1y,
                            dUV2x*dUV2x + dUV2y*dUV2y)));

            // Skip degenerate triangles
            if (diameter < 1e-6f || uvDiameter < 1e-6f)
                continue;

            float triUvScale = diameter / uvDiameter;
            logUvScaleSum += (float)Math.log(triUvScale);
            ++logUvScaleCount;
        }

        pAverageUVScaleOut[0] = (float) Math.exp(logUvScaleSum / logUvScaleCount);

        return GFSDK_FaceWorks_Result.OK;
    }

    /// Calculate size needed to store pixels of texture generated by GFSDK_FaceWorks_GenerateCurvatureLUT.
///
/// \param pConfig				[in] the parameters for building curvature lookup texture for SSS
///
/// \return						the size needed to store pixels of texture generated by
///								GFSDK_FaceWorks_GenerateCurvatureLUT
    public static int GFSDK_FaceWorks_CalculateCurvatureLUTSizeBytes(GFSDK_FaceWorks_CurvatureLUTConfig pConfig){
        if (pConfig == null)
            return 0;

        return 4 * pConfig.m_texWidth * pConfig.m_texHeight;
    }

    /**
     * Generate curvature lookup texture for SSS shaders.<p></p>
     * The image is stored in RGBA8 format to the given pointer, in left-to-right, top-to-bottom order. The curvature LUT is in linear color space.
     * @param pConfig [in] the parameters for building curvature lookup texture for SSS
     * @param pCurvatureLUTOut [out] buffer where the curvature LUT is stored
     * @param pErrorBlobOut [in] buffer the error blob, where errors are stored.Error messages will be stored in the error blob, if one is given;
     *								if error messages are generated, use GFSDK_FaceWorks_FreeErrorBlob()
     *								to free the storage.
     *								The given allocator will be used to allocate temporary storage for
     *								working data, if provided; if not, the standard CRT allocator will
     *								be used.
     * @return GFSDK_FaceWorks_OK if parameters are correct<br>GFSDK_FaceWorks_InvalidArgument if pConfig contains invalid values
     */
    public static GFSDK_FaceWorks_Result GFSDK_FaceWorks_GenerateCurvatureLUT(
            GFSDK_FaceWorks_CurvatureLUTConfig pConfig,
            ByteBuffer pCurvatureLUTOut,GFSDK_FaceWorks_ErrorBlob pErrorBlobOut){
        // Validate parameters
        if (pConfig == null)
        {
            ErrPrintf(pErrorBlobOut, "pConfig is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pCurvatureLUTOut == null)
        {
            ErrPrintf(pErrorBlobOut, "pCurvatureLUTOut is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_diffusionRadius <= 0.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_diffusionRadius is %g; should be greater than 0\n",
                    pConfig.m_diffusionRadius);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_texWidth < 1)
        {
            ErrPrintf(pErrorBlobOut, "m_texWidth is %d; should be at least 1\n",
                    pConfig.m_texWidth);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_texHeight < 1)
        {
            ErrPrintf(pErrorBlobOut, "m_texHeight is %d; should be at least 1\n",
                    pConfig.m_texHeight);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_curvatureRadiusMin <= 0.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_curvatureRadiusMin is %g; should be greater than 0\n",
                    pConfig.m_curvatureRadiusMin);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_curvatureRadiusMax <= 0.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_curvatureRadiusMax is %g; should be greater than 0\n",
                    pConfig.m_curvatureRadiusMax);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_curvatureRadiusMax < pConfig.m_curvatureRadiusMin)
        {
            ErrPrintf(pErrorBlobOut, "m_curvatureRadiusMin is %g and m_curvatureRadiusMax is %g; max should be greater than min\n",
                    pConfig.m_curvatureRadiusMin, pConfig.m_curvatureRadiusMax);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        // The diffusion profile is built assuming a (standard human skin) radius
        // of 2.7 mm, so the curvatures and shadow widths need to be scaled to generate
        // a LUT for the user's desired diffusion radius.
        float diffusionRadiusFactor = pConfig.m_diffusionRadius / 2.7f;

        float curvatureMin = diffusionRadiusFactor / pConfig.m_curvatureRadiusMax;
        float curvatureMax = diffusionRadiusFactor / pConfig.m_curvatureRadiusMin;
        float curvatureScale = (curvatureMax - curvatureMin) / pConfig.m_texHeight;
        float curvatureBias = curvatureMin + 0.5f * curvatureScale;

        float NdotLScale = 2.0f / pConfig.m_texWidth;
        float NdotLBias = -1.0f + 0.5f * NdotLScale;

//        unsigned char * pPx = static_cast<unsigned char *>(pCurvatureLUTOut);

        // !!!UNDONE: SIMD-ize or GPU-ize all this math
        final float[] rgb = new float[3];
        final float[] rgbDiffusion = new float[3];
        for (int iY = 0; iY < pConfig.m_texHeight; ++iY)
        {
            for (int iX = 0; iX < pConfig.m_texWidth; ++iX)
            {
                float NdotL = iX * NdotLScale + NdotLBias;
                float theta = (float) Math.acos(NdotL);

                float curvature = iY * curvatureScale + curvatureBias;
                float radius = 1.0f / curvature;

                // Sample points around a ring, and Monte-Carlo-integrate the
                // scattered lighting using the diffusion profile

                final int cIter = 200;
//                float rgb[3] = { 0.0f, 0.0f, 0.0f };
                rgb[0] = rgb[1] =rgb[2] = 0;

                // Set integration bounds in arc-length in mm on the sphere
                float lowerBound = Math.max(-Numeric.PI*radius, -10.0f);
                float upperBound = Math.min(Numeric.PI*radius, 10.0f);

                float iterScale = (upperBound - lowerBound) / cIter;
                float iterBias = lowerBound + 0.5f * iterScale;

                for (int iIter = 0; iIter < cIter; ++iIter)
                {
                    float delta = iIter * iterScale + iterBias;
//                    float rgbDiffusion[3];
                    EvaluateDiffusionProfile(delta, rgbDiffusion);

                    float NdotLDelta = (float) Math.max(0.0f, Math.cos(theta - delta * curvature));
                    rgb[0] += NdotLDelta * rgbDiffusion[0];
                    rgb[1] += NdotLDelta * rgbDiffusion[1];
                    rgb[2] += NdotLDelta * rgbDiffusion[2];
                }

                // Scale sum of samples to get value of integral
                float scale = (upperBound - lowerBound) / cIter;
                rgb[0] *= scale;
                rgb[1] *= scale;
                rgb[2] *= scale;

                // Calculate delta from standard diffuse lighting (saturate(N.L)) to
                // scattered result, remapped from [-.25, .25] to [0, 1].
                float rgbAdjust = -Math.max(0.0f, NdotL) * 2.0f + 0.5f;
                rgb[0] = rgb[0] * 2.0f + rgbAdjust;
                rgb[1] = rgb[1] * 2.0f + rgbAdjust;
                rgb[2] = rgb[2] * 2.0f + rgbAdjust;

                // Clamp to [0, 1]
                rgb[0] = Math.min(Math.max(rgb[0], 0.0f), 1.0f);
                rgb[1] = Math.min(Math.max(rgb[1], 0.0f), 1.0f);
                rgb[2] = Math.min(Math.max(rgb[2], 0.0f), 1.0f);

                // Convert to integer format (linear RGB space)
//                *(pPx++) = static_cast<unsigned char>(255.0f * rgb[0] + 0.5f);
//                *(pPx++) = static_cast<unsigned char>(255.0f * rgb[1] + 0.5f);
//                *(pPx++) = static_cast<unsigned char>(255.0f * rgb[2] + 0.5f);
//                *(pPx++) = 255;
                pCurvatureLUTOut.put((byte)(255.0f * rgb[0] + 0.5f));
                pCurvatureLUTOut.put((byte)(255.0f * rgb[1] + 0.5f));
                pCurvatureLUTOut.put((byte)(255.0f * rgb[2] + 0.5f));
                pCurvatureLUTOut.put((byte)255);
            }
        }

        return GFSDK_FaceWorks_Result.OK;
    }

    /**
     * Calculate size needed to store pixels of texture generated by GFSDK_FaceWorks_GenerateShadowLUT.
     * @param pConfig [in] the parameters for building shadow lookup texture for SSS
     * @return the size needed to store pixels of texture generated by GFSDK_FaceWorks_GenerateShadowLUT
     */
    public static int GFSDK_FaceWorks_CalculateShadowLUTSizeBytes(GFSDK_FaceWorks_ShadowLUTConfig pConfig){
        if (pConfig == null)
            return 0;

        return 4 * pConfig.m_texWidth * pConfig.m_texHeight;
    }

    static final float diffusionSigmas[] = { 0.080f, 0.220f, 0.432f, 0.753f, 1.411f, 2.722f };
    static final float diffusionWeightsR[] = { 0.233f, 0.100f, 0.118f, 0.113f, 0.358f, 0.078f };
    static final float diffusionWeightsG[] = { 0.455f, 0.336f, 0.198f, 0.007f, 0.004f, 0.000f };
    static final float diffusionWeightsB[] = { 0.649f, 0.344f, 0.000f, 0.007f, 0.000f, 0.000f };
    static final float rsqrtTwoPi = 0.39894228f;

    static void EvaluateDiffusionProfile(float x, float[] rgb)	// x in millimeters
    {
        rgb[0] = 0.0f;
        rgb[1] = 0.0f;
        rgb[2] = 0.0f;

        for (int i = 0; i < diffusionSigmas.length; ++i)
        {
            float sigma = diffusionSigmas[i];
            float gaussian = (float) ((rsqrtTwoPi / sigma) * Math.exp(-0.5f * (x*x) / (sigma*sigma)));

            rgb[0] += diffusionWeightsR[i] * gaussian;
            rgb[1] += diffusionWeightsG[i] * gaussian;
            rgb[2] += diffusionWeightsB[i] * gaussian;
        }
    }

    /**
     * Generate shadow lookup texture for SSS shaders.<p></p>
     * The image is stored in RGBA8 format to the given pointer, in left-to-right, top-to-bottom order.<p></p>
     * The shadow LUT is in sRGB color space.
     * @param pConfig [in] the parameters for building shadow lookup texture for SSS
     * @param pShadowLUTOut [out] buffer where the shadow LUT is stored
     * @param pErrorBlobOut [in] buffer the error blob, where errors are stored.Error messages will be stored in the error blob, if one is given;
     *								if error messages are generated, use GFSDK_FaceWorks_FreeErrorBlob()
     *								to free the storage.
     *								The given allocator will be used to allocate temporary storage for
     *								working data, if provided; if not, the standard CRT allocator will
     *								be used.
     * @return GFSDK_FaceWorks_OK if parameters are correct<br>GFSDK_FaceWorks_InvalidArgument if pConfig contains invalid values
     */
    public static GFSDK_FaceWorks_Result GFSDK_FaceWorks_GenerateShadowLUT(GFSDK_FaceWorks_ShadowLUTConfig pConfig,
            ByteBuffer pShadowLUTOut,GFSDK_FaceWorks_ErrorBlob pErrorBlobOut){
        if (pConfig == null)
        {
            ErrPrintf(pErrorBlobOut, "pConfig is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pShadowLUTOut == null)
        {
            ErrPrintf(pErrorBlobOut, "pShadowLUTOut is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_diffusionRadius <= 0.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_diffusionRadius is %g; should be greater than 0\n",
                    pConfig.m_diffusionRadius);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_texWidth < 1)
        {
            ErrPrintf(pErrorBlobOut, "m_texWidth is %d; should be at least 1\n",
                    pConfig.m_texWidth);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_texHeight < 1)
        {
            ErrPrintf(pErrorBlobOut, "m_texHeight is %d; should be at least 1\n",
                    pConfig.m_texHeight);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_shadowWidthMin <= 0.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_shadowWidthMin is %g; should be greater than 0\n",
                    pConfig.m_shadowWidthMin);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_shadowWidthMax <= 0.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_shadowWidthMax is %g; should be greater than 0\n",
                    pConfig.m_shadowWidthMax);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_shadowWidthMax < pConfig.m_shadowWidthMin)
        {
            ErrPrintf(pErrorBlobOut, "m_shadowWidthMin is %g and m_shadowWidthMax is %g; max should be greater than min\n",
                    pConfig.m_shadowWidthMin, pConfig.m_shadowWidthMax);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_shadowSharpening < 1.0f)
        {
            ErrPrintf(pErrorBlobOut, "m_shadowSharpening is %g; should be at least 1.0\n",
                    pConfig.m_shadowSharpening);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        // The diffusion profile is built assuming a (standard human skin) radius
        // of 2.7 mm, so the curvatures and shadow widths need to be scaled to generate
        // a LUT for the user's desired diffusion radius.
        float diffusionRadiusFactor = pConfig.m_diffusionRadius / 2.7f;

        float shadowRcpWidthMin = diffusionRadiusFactor / pConfig.m_shadowWidthMax;
        float shadowRcpWidthMax = diffusionRadiusFactor / pConfig.m_shadowWidthMin;
        float shadowScale = (shadowRcpWidthMax - shadowRcpWidthMin) /pConfig.m_texHeight;
        float shadowBias = shadowRcpWidthMin + 0.5f * shadowScale;

//        unsigned char * pPx = static_cast<unsigned char *>(pShadowLUTOut);

        // !!!UNDONE: SIMD-ize or GPU-ize all this math
        final float[] rgb = new float[3];
        final float[] rgbDiffusion = new float[3];
        for (int iY = 0; iY < pConfig.m_texHeight; ++iY)
        {
            for (int iX = 0; iX < pConfig.m_texWidth; ++iX)
            {
                // Calculate input position relative to the shadow edge, by approximately
                // inverting the transfer function of a disc or Gaussian filter.
                float u = (iX + 0.5f) / pConfig.m_texWidth;
                float inputPos = (float) ((Math.sqrt(u) - Math.sqrt(1.0f - u)) * 0.5f + 0.5f);

                float rcpWidth = iY * shadowScale + shadowBias;

                // Sample points along a line perpendicular to the shadow edge, and
                // Monte-Carlo-integrate the scattered lighting using the diffusion profile

                final int cIter = 200;
                rgb[0] = 0;
                rgb[1] = 0;
                rgb[2] = 0;
                float iterScale = 20.0f / cIter;
                float iterBias = -10.0f + 0.5f * iterScale;

                for (int iIter = 0; iIter < cIter; ++iIter)
                {
                    float delta = iIter * iterScale + iterBias;
                    EvaluateDiffusionProfile(delta, rgbDiffusion);

                    // Use smoothstep as an approximation of the transfer function of a
                    // disc or Gaussian filter.
                    float newPos = (inputPos + delta * rcpWidth) * pConfig.m_shadowSharpening +
                            (-0.5f * pConfig.m_shadowSharpening + 0.5f);
                    float newPosClamped = Math.min(Math.max(newPos, 0.0f), 1.0f);
                    float newShadow = (3.0f - 2.0f * newPosClamped) * newPosClamped * newPosClamped;

                    rgb[0] += newShadow * rgbDiffusion[0];
                    rgb[1] += newShadow * rgbDiffusion[1];
                    rgb[2] += newShadow * rgbDiffusion[2];
                }

                // Scale sum of samples to get value of integral.  Also hack in a
                // fade to ensure the left edge of the image goes strictly to zero.
                float scale = 20.0f / cIter;
                if (iX * 25 < pConfig.m_texWidth)
                {
                    scale *= Math.min(25.0f * iX / pConfig.m_texWidth, 1.0f);
                }
                rgb[0] *= scale;
                rgb[1] *= scale;
                rgb[2] *= scale;

                // Clamp to [0, 1]
                rgb[0] = Math.min(Math.max(rgb[0], 0.0f), 1.0f);
                rgb[1] = Math.min(Math.max(rgb[1], 0.0f), 1.0f);
                rgb[2] = Math.min(Math.max(rgb[2], 0.0f), 1.0f);

                // Convert linear to sRGB
                rgb[0] = (rgb[0] < 0.0031308f) ? (12.92f * rgb[0]) : (1.055f * (float)Math.pow(rgb[0], 1.0f / 2.4f) - 0.055f);
                rgb[1] = (rgb[1] < 0.0031308f) ? (12.92f * rgb[1]) : (1.055f * (float)Math.pow(rgb[1], 1.0f / 2.4f) - 0.055f);
                rgb[2] = (rgb[2] < 0.0031308f) ? (12.92f * rgb[2]) : (1.055f * (float)Math.pow(rgb[2], 1.0f / 2.4f) - 0.055f);

                // Convert to integer format
//                *(pPx++) = static_cast<unsigned char>(255.0f * rgb[0] + 0.5f);
//                *(pPx++) = static_cast<unsigned char>(255.0f * rgb[1] + 0.5f);
//                *(pPx++) = static_cast<unsigned char>(255.0f * rgb[2] + 0.5f);
//                *(pPx++) = 255;
                pShadowLUTOut.put((byte)(255.0f * rgb[0] + 0.5f));
                pShadowLUTOut.put((byte)(255.0f * rgb[1] + 0.5f));
                pShadowLUTOut.put((byte)(255.0f * rgb[2] + 0.5f));
                pShadowLUTOut.put((byte)255);
            }
        }

        return GFSDK_FaceWorks_Result.OK;
    }

    private static GFSDK_FaceWorks_Result ValidateSSSConfig(
            GFSDK_FaceWorks_SSSConfig pConfig,
            GFSDK_FaceWorks_ErrorBlob pErrorBlobOut)
    {
        if (pConfig == null)
        {
            ErrPrintf(pErrorBlobOut, "pConfig is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        if (pConfig.m_diffusionRadius <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_diffusionRadius is %g; should be greater than 0.0\n",
                    pConfig.m_diffusionRadius);
        }
        if (pConfig.m_diffusionRadiusLUT <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_diffusionRadiusLUT is %g; should be greater than 0.0\n",
                    pConfig.m_diffusionRadius);
        }
        if (pConfig.m_curvatureRadiusMinLUT <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_curvatureRadiusMinLUT is %g; should be greater than 0.0\n",
                    pConfig.m_curvatureRadiusMinLUT);
        }
        if (pConfig.m_curvatureRadiusMaxLUT <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_curvatureRadiusMaxLUT is %g; should be greater than 0.0\n",
                    pConfig.m_curvatureRadiusMaxLUT);
        }
        if (pConfig.m_curvatureRadiusMaxLUT < pConfig.m_curvatureRadiusMinLUT)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_curvatureRadiusMaxLUT (%g) is less than pConfig.m_curvatureRadiusMinLUT (%g)\n",
                    pConfig.m_curvatureRadiusMaxLUT, pConfig.m_curvatureRadiusMinLUT);
        }
        if (pConfig.m_shadowWidthMinLUT <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_shadowWidthMinLUT is %g; should be greater than 0.0\n",
                    pConfig.m_shadowWidthMinLUT);
        }
        if (pConfig.m_shadowWidthMaxLUT <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_shadowWidthMaxLUT is %g; should be greater than 0.0\n",
                    pConfig.m_shadowWidthMaxLUT);
        }
        if (pConfig.m_shadowWidthMaxLUT < pConfig.m_shadowWidthMinLUT)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_shadowWidthMaxLUT (%g) is less than pConfig.m_shadowWidthMinLUT (%g)\n",
                    pConfig.m_shadowWidthMaxLUT, pConfig.m_shadowWidthMinLUT);
        }
        if (pConfig.m_shadowFilterWidth <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_shadowFilterWidth is %g; should be greater than 0.0\n",
                    pConfig.m_shadowFilterWidth);
        }
        if (pConfig.m_normalMapSize < 0)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_normalMapSize is %d; should be at least 0\n",
                    pConfig.m_normalMapSize);
        }
        if (pConfig.m_averageUVScale <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_averageUVScale is %g; should be greater than 0.0\n",
                    pConfig.m_averageUVScale);
        }

        return GFSDK_FaceWorks_Result.OK;
    }

    /**
     * Write constant buffer data for SSS, using specified configuration options.<p></p>
     * @param pConfig [in] pointer to runtime config struct for SSS
     * @param pCBDataOut [out] pointer to CBData struct in your constant buffer
     * @param pErrorBlobOut [in] buffer the error blob, where errors are stored.Error messages will be stored in the error blob, if one is given;
     *								if error messages are generated, use GFSDK_FaceWorks_FreeErrorBlob()
     *								to free the storage.
     *								The given allocator will be used to allocate temporary storage for
     *								working data, if provided; if not, the standard CRT allocator will
     *								be used.
     * @return GFSDK_FaceWorks_OK if parameters are correct<br>GFSDK_FaceWorks_InvalidArgument if pConfig contains invalid values.
     */
    public static GFSDK_FaceWorks_Result GFSDK_FaceWorks_WriteCBDataForSSS(GFSDK_FaceWorks_SSSConfig pConfig,
            GFSDK_FaceWorks_CBData pCBDataOut,GFSDK_FaceWorks_ErrorBlob pErrorBlobOut){
        // Validate params

        GFSDK_FaceWorks_Result res = ValidateSSSConfig(pConfig, pErrorBlobOut);
        if (res != GFSDK_FaceWorks_Result.OK)
            return res;

        if (pCBDataOut == null)
        {
            ErrPrintf(pErrorBlobOut, "GFSDK_FaceWorks_WriteCBDataForSSS: pCBDataOut is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        // The LUTs are built assuming a particular scattering radius, so the
        // curvatures and penumbra widths need to be scaled to match the
        // scattering radius set at runtime.
        float diffusionRadiusFactor = pConfig.m_diffusionRadiusLUT / pConfig.m_diffusionRadius;

        // Set up the constant buffer
        float curvatureMin = diffusionRadiusFactor / pConfig.m_curvatureRadiusMaxLUT;
        float curvatureMax = diffusionRadiusFactor / pConfig.m_curvatureRadiusMinLUT;
        float curvatureScale = 1.0f / (curvatureMax - curvatureMin);
        float curvatureBias = -curvatureMin * curvatureScale;

        float shadowRcpWidthMin = diffusionRadiusFactor / pConfig.m_shadowWidthMaxLUT;
        float shadowRcpWidthMax = diffusionRadiusFactor / pConfig.m_shadowWidthMinLUT;
        float shadowScale = 1.0f / (shadowRcpWidthMax - shadowRcpWidthMin);
        float shadowBias = -shadowRcpWidthMin * shadowScale;

        float minLevelForBlurredNormal = (float) (Math.log(Math.max(
                        pConfig.m_normalMapSize * pConfig.m_diffusionRadius,
                        pConfig.m_averageUVScale)
                        / pConfig.m_averageUVScale)/Math.log(2));

        // Output to user buffer
        pCBDataOut.data[0] = curvatureScale;
        pCBDataOut.data[1] = curvatureBias;
        pCBDataOut.data[2] = shadowScale / pConfig.m_shadowFilterWidth;
        pCBDataOut.data[3] = shadowBias;
        pCBDataOut.data[4] = minLevelForBlurredNormal;

        return GFSDK_FaceWorks_Result.OK;
    }

    // ======================================================================================
//     Runtime API for deep scatter
// ======================================================================================

    private static GFSDK_FaceWorks_Result ValidateDeepScatterConfig(
            GFSDK_FaceWorks_DeepScatterConfig pConfig,
            GFSDK_FaceWorks_ErrorBlob pErrorBlobOut)
    {
        if (pConfig == null)
        {
            ErrPrintf(pErrorBlobOut, "pConfig is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        if (pConfig.m_radius <= 0.0f)
        {
            WarnPrintf(pErrorBlobOut,
                    "pConfig.m_radius is %g; should be greater than 0.0\n",
                    pConfig.m_radius);
        }
        if (pConfig.m_shadowProjType != GFSDK_FaceWorks_ProjectionType.NoProjection &&
                pConfig.m_shadowProjType != GFSDK_FaceWorks_ProjectionType.ParallelProjection &&
                        pConfig.m_shadowProjType != GFSDK_FaceWorks_ProjectionType.PerspectiveProjection)
        {
            ErrPrintf(pErrorBlobOut,
                    "pConfig.m_shadowProjType is %d; not a valid GFSDK_FaceWorks_ProjectionType enum value\n",
                    pConfig.m_shadowProjType);
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }
        if (pConfig.m_shadowProjType != GFSDK_FaceWorks_ProjectionType.NoProjection)
        {
            // Error checking for shadow parameters is done only if enabled by the projection type
            if (pConfig.m_shadowFilterRadius < 0.0f)
            {
                WarnPrintf(pErrorBlobOut,
                        "pConfig.m_shadowFilterRadius is %g; should be at least 0.0\n",
                        pConfig.m_shadowFilterRadius);
            }

            // Should we check that m_shadowProjMatrix is of the expected form
            // (e.g. has zeros in the expected places)?
        }

        return GFSDK_FaceWorks_Result.OK;
    }

    /**
     * Write constant buffer data for deep scatter, using specified configuration options.
     * @param pConfig [in] pointer to runtime config struct for Deep Scatter
     * @param pCBDataOut [out] pointer to CBData struct in your constant buffer
     * @param pErrorBlobOut [in] buffer the error blob, where errors are stored.
     *								Error messages will be stored in the error blob, if one is given;
     *								if error messages are generated, use GFSDK_FaceWorks_FreeErrorBlob()
     *								to free the storage.
     *								The given allocator will be used to allocate temporary storage for
     *								working data, if provided; if not, the standard CRT allocator will
     *								be used.
     * @return GFSDK_FaceWorks_OK if parameters are correct<p></p>GFSDK_FaceWorks_InvalidArgument if pConfig contains invalid values
     */
    public static GFSDK_FaceWorks_Result GFSDK_FaceWorks_WriteCBDataForDeepScatter(
            GFSDK_FaceWorks_DeepScatterConfig pConfig,
            GFSDK_FaceWorks_CBData pCBDataOut,
            GFSDK_FaceWorks_ErrorBlob pErrorBlobOut){
        // Validate params

        GFSDK_FaceWorks_Result res = ValidateDeepScatterConfig(pConfig, pErrorBlobOut);
        if (res != GFSDK_FaceWorks_Result.OK)
            return res;

        if (pCBDataOut == null)
        {
            ErrPrintf(pErrorBlobOut, "pCBDataOut is null\n");
            return GFSDK_FaceWorks_Result.InvalidArgument;
        }

        // Set up the constant buffer

        // -0.7213475f = -1 / (2 * ln(2)) - this conversion lets us write this in the shader:
        //     exp2(deepScatterFalloff * thickness^2)
        // instead of this:
        //     exp(-thickness^2 / (2 * radius^2))
        float deepScatterFalloff = -0.7213475f / (pConfig.m_radius * pConfig.m_radius);

        // Calculate depth-decoding parameters from the projection matrix
        float decodeDepthScale = 0.0f;
        float decodeDepthBias = 0.0f;
        switch (pConfig.m_shadowProjType)
        {
            case NoProjection:
                break;	// Nothing to do

            case ParallelProjection:
                decodeDepthScale = -2.0f / pConfig.m_shadowProjMatrix.m22;
//                decodeDepthBias = -pConfig.m_shadowProjMatrix.m32/pConfig.m_shadowProjMatrix.m22;
                break;

            case PerspectiveProjection:
                decodeDepthScale = pConfig.m_shadowFar * pConfig.m_shadowNear / (pConfig.m_shadowFar - pConfig.m_shadowNear);
                decodeDepthBias = pConfig.m_shadowFar / (pConfig.m_shadowFar - pConfig.m_shadowNear);
                break;

            default:
                assert(false);
                return GFSDK_FaceWorks_Result.InvalidArgument;
        }



        // Output to user buffer
        pCBDataOut.data[5] = deepScatterFalloff;
        pCBDataOut.data[6] = pConfig.m_shadowFilterRadius;
        pCBDataOut.data[7] = decodeDepthScale;
        pCBDataOut.data[8] = decodeDepthBias;

        return GFSDK_FaceWorks_Result.OK;
    }
}
